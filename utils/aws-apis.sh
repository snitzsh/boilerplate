#!/bin/bash

#
# TODO:
#   - Lock aws api version
#
# NOTE:
#   - DOC:
#     - https://docs.aws.amazon.com/cli/latest/topic/return-codes.html
#
# DESCRIPTION:
#   - null
#
# ARGS:
#   - null
#
# RETURN:
#   - null
#

function utilsAwsApis () {
  # local -r func_name="${FUNCNAME[0]}"
  local -ar args=("$@")
  local -r query_name="${args[0]}"
  local -r cloud_account="${args[1]}"
  local -r cloud_profile="${args[2]}"
  local -r cloud_region="${args[3]}"
  local -r utc_timestamp=$(date -u +%s)
  local output_path_folder="${CACHE_PATH}"
  # Creates folder if doesn't exist.
  mkdir -p "${output_path_folder}/aws"
  # NOTE
  #  - jq doesn't have in-place command. So the work around is use `_<[file]>.json`
  local curl_output_file="${output_path_folder}/aws/${cloud_account}-${cloud_region}-_${query_name}.json"
  local api_file_name="${output_path_folder}/aws/${cloud_account}-${cloud_region}-${query_name}.json"

  if [ -f "${api_file_name}" ]; then
    rm "${api_file_name}"
  fi

  local allow_api_request="false"
  # NOTE:
  # - 0   200 - Success
  # - 1       - s3 limited. at least one or more s3 transfers failed for the command executed.
  # - 2       - unknown arguments, etc.
  # - 130     - if you kill the command.
  # - 255     - Command failed
  local -ar no_skip_cache_status_codes=( \
    "0" \
    "1" \
    "2" \
    "130" \
    "255" \
  )

  if [ -f "${api_file_name}" ]; then
    allow_api_request=$( \
      jq \
        -r \
        --arg current_timestamp "${utc_timestamp}" \
        --arg trottle_interval "${GITHUB_API_THROTTLE_INTEVAL}" \
        --arg no_skip_cache_status_code "${no_skip_cache_status_codes[*]}" \
        '
          ($no_skip_cache_status_code | split(" ")) as $status_codes
          | if .timestamp == null or .data == null then
              true
            else
              .status as $status
              | (($current_timestamp | tonumber) - .timestamp) > ($trottle_interval | tonumber)
              | if (. == false) and (($status_codes | index($status)) == null) then
                  true
                end
            end
        ' "${api_file_name}" \
    )
  else
    allow_api_request="true"
  fi

  local data=""
  local status=""

  if [ "${allow_api_request}" == "true" ]; then
    case "${query_name}" in
      "secretsmanager-list-secrets")
        data=$( \
          aws \
            --profile="${cloud_profile}" \
            --region="${cloud_region}" \
            --output="json" \
            secretsmanager \
            list-secrets \
          2>&1 \
        )
        status=$?
        ;;
      "secretsmanager-get-secret-value")
        #
        # NOTE:
        #   - if --query is used, then --output must be `text`
        #
        local -r secret_arn="${args[4]}"
        data=$( \
          aws \
            --profile="${cloud_profile}" \
            --region="${cloud_region}" \
            --output="text" \
            secretsmanager \
              get-secret-value \
              --secret-id "${secret_arn}" \
              --query SecretString \
          2>&1 \
        )
        status=$?
        ;;
      #
      # TODO:
      #   - create tags, right now we need to fix clusters.yaml, because
      #     .dev can only have one cluster. we need to support multiple cluster per
      #     stage.
      #
      # NOTE:
      #   - Must filepath for any secret.
      #
      "secretsmanager-create-secret")
        local -r secret_name="${args[4]}"
        local -r full_secret_path="${args[5]}"
        data=$( \
          aws \
            --profile="${cloud_profile}" \
            --region="${cloud_region}" \
            --output="json" \
            secretsmanager \
              create-secret \
              --name "$secret_name" \
              --description "Generated by boilerplate" \
              --secret-string "file://${full_secret_path}.json" \
          2>&1 \
        )
        status=$?
        ;;
      "secretsmanager-delete-secret")
        local -r secret_name="${args[4]}"
        data=$( \
          aws \
            --profile="${cloud_profile}" \
            --region="${cloud_region}" \
            --output="json" \
            secretsmanager \
              delete-secret \
              --secret-id "${secret_name}" \
                --force-delete-without-recovery \
          2>&1 \
        )
        status=$?
        ;;
      *)
        ;;
    esac

    #
    # NOTE
    #   - data is the error message from aws.
    #
    if [[ "$status" -ne 0 ]]; then
      jq \
        -n \
        --arg status "${status}" \
        --arg data "${data}" \
        '
          {
            "message": $data,
            "status": $status
          }
        ' > "${curl_output_file}"
    else
      jq \
        -n \
        --arg status "${status}" \
        --argjson data "${data}" \
        '
          $data
        ' > "${curl_output_file}"
    fi

    # Handler of all api responses.
    jq \
      --arg timestamp "${utc_timestamp}" \
      --arg data "${data}" \
      --arg status "${status}" \
      '
        {
          "data": .,
          "status": $status,
          "timestamp": ($timestamp | tonumber)
        }
      ' "${curl_output_file}" > "${api_file_name}"
  fi
  #
  # NOTE
  # - jq doesn't allow you to update the file like yq -ri this is the work
  #   around.
  #
  if [ -f "${curl_output_file}" ]; then
    rm "${curl_output_file}"
  fi
}
